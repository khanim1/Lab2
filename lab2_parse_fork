#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/wait.h>
int main (int argc, char* argv[]) {

int  max_args = 15;
int max_argv_size = max_args + 2; //one for argv[0], one for null terminator
char* cmds_args[max_args];
char* my_argv[max_argv_size];
char* cmds[max_args];
char** args[max_args];
int size = 50;
char buffer[size];

printf("Input: ");

char* input_string = fgets(buffer, size, stdin);
                if(input_string==0){//for EOF with cntrl+D
                        printf("EOF\n");
                        printf("Goodbye\n");
                       // exit(-1);
                       return 0;
                }
//                printf("%s\n", input_string);
                if(input_string[strlen(input_string)-1] == '\n'){
                        input_string[strlen(input_string)-1] = 0;
                }


//fgets(buffer,size,stdin);
int i = 0;
int j=0;
cmds_args[i] = strtok(buffer,"("); //stores commands and args initially
char* ret = strtok(NULL,"(");
while (ret!=NULL) {
i++;
if (i == max_args) {
printf("Too many commands \n");
//exit(-1);
return 0;
}
cmds_args[i] = ret;
ret = strtok(NULL,"(");
}
int l = i; //remember i for later
for (i; i>=0; --i) {
cmds[j] = strtok(cmds_args[i]," \n"); //array of commands only
//*CMDS IN EXECUTION ORDER, LAST IS FIRST
//char* my_argv[max_argv_size];
my_argv[0] = cmds[j]; //my_argv[0] must contain 
//function name, used in execvp via args[] (see below)
ret = strtok(NULL, " \n");
int m = 0;
while (ret != NULL) {
m++;
if (m==max_args) {
printf("Too many arguments \n");
//exit(-1);
return 0;
}

my_argv[m] = ret;
ret = strtok(NULL," \n");
}
my_argv[m+1] = '\0';
if (my_argv[2] == NULL) {
}

args[j] = my_argv; //array of my_argv's correlates with cmd[]
j++;
}
j = 0;
i=0;
int ret_val;
int frk;
//int* newpipe;
int* oldpipe;
int err;
for (j;j<=l;j++) {
int newpipe[2];
if (j!=l) {
//int fd[2];
//newpipe = fd;
pipe(newpipe);
frk = fork();
i++;
}
if (j==0) {
if (frk ==0) {
err = dup2(newpipe[1],STDOUT_FILENO);
if(err == -1) perror ("Error dup'ing: ");
printf("made it \n");
ret_val = execvp(cmds[j],args[j]);
if (ret_val == -1) perror ("Error exec'ing");
close(newpipe[0]);
oldpipe = newpipe;
}
close(newpipe[1]);
}

if (j==l) {
frk = fork();
if (frk==0) {
dup2(oldpipe[0],STDIN_FILENO);
ret_val = execvp(cmds[j],args[j]);
if (ret_val == -1) perror ("Error exec'ing");
close(oldpipe[1]);
}
close(oldpipe[0]);

}

else {
if (frk==0) {
dup2(newpipe[1],STDOUT_FILENO);
dup2(oldpipe[0],STDIN_FILENO);
ret_val = execvp(cmds[j],args[j]);
if (ret_val == -1) perror ("Error exec'ing");
close(oldpipe[1]);
close(newpipe[0]);
oldpipe = newpipe;
}
close(newpipe[1]);
close(oldpipe[0]);
}

}
int q;
for (q=0;q<i;q++) {
waitpid(-1,NULL,0);
}
return 0;
}
